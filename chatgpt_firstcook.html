<!-- /index.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>주사위 보드 이동 게임 (30칸·멀티플레이어 + 요리)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <meta name="description" content="5×6(30칸) 지그재그 보드에서 주사위를 굴려 앞으로만 이동하고, 각 칸의 3개 재료 중 1개를 골라 모은 뒤 요리를 만드는 턴제 게임. 플레이어 수 1–6 지원. 실시간 멀티플레이(파이어베이스)." />
  <style>
    canvas { image-rendering: pixelated; }
    .modal { position: fixed; inset: 0; display: none; }
    .modal.show { display: grid; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-800">
  <header class="sticky top-0 z-10 bg-white/80 backdrop-blur border-b border-slate-200">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
      <h1 class="text-xl md:text-2xl font-semibold">🎲 30칸 주사위 보드 게임</h1>
      <div class="text-sm text-slate-500">HTML5 • CSS3(Tailwind) • JavaScript • Firebase</div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
    <!-- Canvas Area -->
    <section class="lg:col-span-2">
      <div class="relative bg-white rounded-2xl shadow p-4 flex flex-col gap-3">
        <!-- Multiplayer bar -->
        <div class="grid md:grid-cols-2 gap-3">
          <div class="rounded-xl border p-3">
            <div class="flex items-center justify-between">
              <h3 class="font-semibold">멀티플레이</h3>
              <span id="mpStatus" class="text-xs text-slate-500">로컬 모드</span>
            </div>
            <div class="mt-2 grid grid-cols-2 gap-2">
              <input id="nameInput" class="col-span-2 md:col-span-1 px-2 py-1 rounded-lg border" placeholder="닉네임" />
              <input id="roomInput" class="col-span-2 md:col-span-1 px-2 py-1 rounded-lg border font-mono" placeholder="방 코드(예: ABC123)"/>
              <button id="createRoomBtn" class="px-2 py-1 rounded-lg bg-indigo-500 text-white">방 만들기</button>
              <button id="joinRoomBtn" class="px-2 py-1 rounded-lg border">입장</button>
              <button id="startOnlineBtn" class="px-2 py-1 rounded-lg bg-emerald-500 text-white" title="호스트만 가능">온라인 시작</button>
              <button id="leaveRoomBtn" class="px-2 py-1 rounded-lg border">나가기</button>
            </div>
            <p class="mt-2 text-xs text-slate-500">※ 방을 만들고 코드를 공유하세요. 모든 플레이어가 입장하면 <b>온라인 시작</b> 버튼으로 게임을 시작합니다.</p>
          </div>
          <div class="rounded-xl border p-3">
            <div class="flex items-center justify-between text-sm text-slate-600">
              <div>
                보드: 5×6 지그재그(총 <span id="tilesCount">30</span>칸) · 0~4 / 9~5 / 10~14 / 19~15 / 20~24 / 29~25
              </div>
              <div class="flex items-center gap-2">
                <span>턴: <span id="turnLabel" class="font-semibold">P1</span></span>
                <span>위치: <span id="posLabel" class="font-mono">0 / 30</span></span>
              </div>
            </div>
            <!-- Orders (좌측 표시) -->
            <div class="mt-3">
              <h3 class="font-semibold">주문 (랜덤 3개)</h3>
              <div id="ordersInfo" class="text-xs text-slate-500 mt-1">판매 대상: <span id="ordersTarget">P1</span> · 주문 요리는 2배 지급 & 완성한 요리 +1</div>
              <div id="orders" class="mt-2 grid grid-cols-3 gap-2"></div>
            </div>
          </div>
        </div>

        <canvas id="game" width="640" height="480" class="w-full max-w-full rounded-xl border border-slate-200 mt-2"></canvas>
      </div>
    </section>

    <!-- Sidebar / Controls -->
    <aside class="lg:col-span-1">
      <div class="bg-white rounded-2xl shadow p-4 flex flex-col gap-4">
        <div>
          <h2 class="font-semibold">주사위</h2>
          <div class="flex items-center gap-2 mt-2">
            <button id="rollBtn" class="px-4 py-2 rounded-xl bg-indigo-500 hover:bg-indigo-600 text-white">주사위 굴리기 (R)</button>
            <div class="flex items-center gap-2">
              <span class="text-sm text-slate-600">결과</span>
              <div id="diceFace" class="w-12 h-12 grid place-items-center border rounded-xl text-lg font-bold">–</div>
            </div>
          </div>
        </div>

        <div>
          <h2 class="font-semibold">이동</h2>
          <div class="grid grid-cols-2 gap-2 mt-2">
            <button id="moveForward" disabled class="px-3 py-2 rounded-xl bg-emerald-500 text-white disabled:bg-slate-300 disabled:cursor-not-allowed">앞으로 이동 (Enter/↑)</button>
            <button id="passBtn" class="px-3 py-2 rounded-xl border bg-white hover:bg-slate-50 disabled:bg-slate-200">차례 넘기기 (N)</button>
          </div>
          <p id="hint" class="mt-2 text-sm text-slate-600">플레이어 수를 선택 후 시작합니다.</p>
        </div>

        <div>
          <div class="flex items-center justify-between">
            <h2 class="font-semibold">플레이어</h2>
            <button id="resetBtn" class="text-xs px-2 py-1 border rounded-lg">재시작(로컬)</button>
          </div>
          <div id="playerTabs" class="mt-2 flex flex-wrap gap-2"></div>
        </div>

        <div>
          <div class="flex items-center justify-between">
            <h2 class="font-semibold">인벤토리 (<span id="viewLabel">P1</span>)</h2>
            <div class="flex items-center gap-2">
              <button id="invToggle" class="text-xs px-2 py-1 border rounded-lg">접기</button>
              <button id="allInvToggle" class="text-xs px-2 py-1 border rounded-lg">모두 보기</button>
              <button id="cookBtn" class="text-xs px-2 py-1 rounded-lg bg-rose-500 text-white hover:bg-rose-600">요리하기</button>
            </div>
          </div>
          <div class="flex items-center justify-between mt-1 text-sm">
            <div>남은 돈: <span id="moneyLabel">0</span>원</div>
            <div>완성한 요리: <span id="dishesLabel">0</span>개</div>
          </div>
          <div id="inventory" class="mt-2 space-y-3 text-sm"></div>
        </div>

        <div>
          <h2 class="font-semibold">현재 칸 선택 (<span id="tileIndex">0</span>)</h2>
          <div id="choices" class="mt-2 grid grid-cols-3 gap-2"></div>
        </div>

        <!-- 가격표 (접기 가능) -->
        <div>
          <div class="flex items-center justify-between">
            <h3 class="font-semibold">가격표</h3>
            <button id="priceToggle" class="text-xs px-2 py-1 border rounded-lg">접기</button>
          </div>
          <div id="priceList" class="mt-2 grid grid-cols-2 gap-2 text-sm"></div>
        </div>

        <div>
          <h3 class="font-semibold">로그</h3>
          <div id="log" class="mt-2 h-40 overflow-auto text-sm bg-slate-50 border rounded-xl p-2"></div>
        </div>
      </div>
    </aside>
  </main>

  <!-- Cook Modal -->
  <div id="cookModal" class="modal place-items-center bg-black/40 p-4">
    <div class="bg-white w-full max-w-3xl rounded-2xl shadow-xl p-4">
      <div class="flex items-center justify-between">
        <h3 class="text-lg font-semibold">요리 선택</h3>
        <button id="cookClose" class="px-2 py-1 text-sm border rounded-lg">닫기</button>
      </div>
      <div id="cookList" class="mt-3 grid grid-cols-2 lg:grid-cols-3 gap-3 max-h-[60vh] overflow-auto"></div>
    </div>
  </div>

  <footer class="max-w-6xl mx-auto px-4 pb-8 text-xs text-slate-500">
    Made with ❤️ HTML5 Canvas, TailwindCSS, Vanilla JS & Firebase.
  </footer>

  <script>
    // ===== Config =====
    const TILE = 80;          // 보드 타일 크기
    const MARGIN = 24;        // 외곽 여백
    const COLS = 5;
    const ROWS = 6;           // 총 30칸
    const START_MONEY = 1000; // 초기 자금
    const PASS_ZERO_REWARD = 500; // 0칸 통과 보상
    const ORDER_COUNT = 3;    // 주문 개수
    const ROLLS_BEFORE_RESET = 5; // 모든 플레이어 주사위 5회 후 재료 리셋

    const PLAYER_COLORS = ['#0ea5e9','#10b981','#f59e0b','#ef4444','#8b5cf6','#14b8a6'];

    // 🔧 Firebase 프로젝트 설정을 입력하세요 (console.firebase.google.com → 프로젝트 설정 → 일반 → SDK 설정 및 구성)
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyDYHa1nSWOiM7UNv_NoHUfxEvTkbN3Z7fI",
      authDomain: "coooooking-94b01.firebaseapp.com",
      projectId: "coooooking-94b01",
      appId: "1:328606094566:web:5210db144f6d1563109727"
    };

    // ===== Data =====
    const INGREDIENTS = [
      { id:'kimchi',        label:'김치',         icon:'🥬', price:200, color:'#16a34a' },
      { id:'rice',          label:'밥',           icon:'🍚', price:100, color:'#e5e7eb' },
      { id:'mushroom',      label:'버섯',         icon:'🍄', price:150, color:'#a78bfa' },
      { id:'salmon',        label:'연어',         icon:'🐟', price:300, color:'#60a5fa' },
      { id:'seaweed',       label:'김',           icon:'🟩', price:120, color:'#10b981' },
      { id:'noodle',        label:'면',           icon:'🍜', price:150, color:'#f59e0b' },
      { id:'broth',         label:'육수',         icon:'🥣', price:180, color:'#fde68a' },
      { id:'egg',           label:'계란',         icon:'🥚', price:120, color:'#fef08a' },
      { id:'bread',         label:'빵',           icon:'🍞', price:150, color:'#fbbf24' },
      { id:'cheese',        label:'치즈',         icon:'🧀', price:200, color:'#facc15' },
      { id:'tomato_sauce',  label:'토마토 소스',  icon:'🍅', price:180, color:'#ef4444' },
      { id:'beef',          label:'소고기',       icon:'🥩', price:300, color:'#ef4444' },
      { id:'onion',         label:'양파',         icon:'🧅', price:100, color:'#f97316' },
      { id:'flour',         label:'밀가루',       icon:'🌾', price:130, color:'#eab308' },
      { id:'milk',          label:'우유',         icon:'🥛', price:130, color:'#93c5fd' },
    ];

    const RECIPES = [
      { id:'kimchi_fried_rice', name:'김치볶음밥', icon:'🍛', reward:500, req:{ kimchi:1, rice:1, mushroom:1 } },
      { id:'salmon_sushi',      name:'연어 초밥',   icon:'🍣', reward:600, req:{ rice:1, salmon:1, seaweed:1 } },
      { id:'ramen',             name:'라멘',       icon:'🍜', reward:500, req:{ noodle:1, broth:1, egg:1 } },
      { id:'pizza',             name:'피자',       icon:'🍕', reward:700, req:{ bread:1, cheese:1, tomato_sauce:1 } },
      { id:'spaghetti',         name:'스파게티',   icon:'🍝', reward:600, req:{ noodle:1, tomato_sauce:1, beef:1 } },
      { id:'burger',            name:'햄버거',     icon:'🍔', reward:650, req:{ bread:1, beef:1, cheese:1 } },
      { id:'bulgogi',           name:'불고기',     icon:'🍖', reward:700, req:{ beef:1, onion:1, mushroom:1 } },
      { id:'pancake',           name:'팬케이크',   icon:'🥞', reward:500, req:{ flour:1, egg:1, milk:1 } },
      { id:'gimbap',            name:'김밥',       icon:'🍙', reward:550, req:{ rice:1, seaweed:1, egg:1 } },
      { id:'kimchi_jeon',       name:'김치전',     icon:'🥞', reward:500, req:{ kimchi:1, flour:1, onion:1 } },
    ];

    // ===== Canvas =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = MARGIN * 2 + COLS * TILE;
    canvas.height = MARGIN * 2 + ROWS * TILE;

    // ===== Path (0..29 serpentine) =====
    const PATH = buildPath();
    function buildPath() {
      const p = [];
      let idx = 0;
      for (let gy = 0; gy < ROWS; gy++) {
        if (gy % 2 === 0) {
          for (let gx = 0; gx < COLS; gx++) { p[idx++] = { gx, gy }; }
        } else {
          for (let gx = COLS - 1; gx >= 0; gx--) { p[idx++] = { gx, gy }; }
        }
      }
      return p; // length 30
    }

    // ===== DOM =====
    const tilesCountEl = document.getElementById('tilesCount');
    const turnLabel = document.getElementById('turnLabel');
    const posLabel = document.getElementById('posLabel');
    const rollBtn = document.getElementById('rollBtn');
    const diceFace = document.getElementById('diceFace');
    const moveForwardBtn = document.getElementById('moveForward');
    const passBtn = document.getElementById('passBtn');
    const hintEl = document.getElementById('hint');
    const logEl = document.getElementById('log');
    const playerTabsEl = document.getElementById('playerTabs');
    const invEl = document.getElementById('inventory');
    const resetBtn = document.getElementById('resetBtn');
    const choicesEl = document.getElementById('choices');
    const viewLabel = document.getElementById('viewLabel');
    const tileIndexEl = document.getElementById('tileIndex');
    const cookBtn = document.getElementById('cookBtn');
    const cookModal = document.getElementById('cookModal');
    const cookClose = document.getElementById('cookClose');
    const cookList = document.getElementById('cookList');
    const moneyLabel = document.getElementById('moneyLabel');
    const dishesLabel = document.getElementById('dishesLabel');
    const invToggle = document.getElementById('invToggle');
    const allInvToggle = document.getElementById('allInvToggle');
    const priceToggle = document.getElementById('priceToggle');
    const priceList = document.getElementById('priceList');
    const ordersEl = document.getElementById('orders');
    const ordersTarget = document.getElementById('ordersTarget');

    const nameInput = document.getElementById('nameInput');
    const roomInput = document.getElementById('roomInput');
    const createRoomBtn = document.getElementById('createRoomBtn');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const leaveRoomBtn = document.getElementById('leaveRoomBtn');
    const startOnlineBtn = document.getElementById('startOnlineBtn');
    const mpStatus = document.getElementById('mpStatus');

    tilesCountEl.textContent = PATH.length;

    // ===== Utils =====
    const mod = (n, m) => ((n % m) + m) % m;
    const centerOf = (gx, gy) => ({ x: MARGIN + gx * TILE + TILE / 2, y: MARGIN + gy * TILE + TILE / 2 });
    const tileRect = (gx, gy) => ({ x: MARGIN + gx * TILE, y: MARGIN + gy * TILE, w: TILE, h: TILE });
    const ingredientMeta = (id) => INGREDIENTS.find(i => i.id === id);
    const priceOf = (id) => ingredientMeta(id)?.price ?? 0;
    const now = () => new Date().toLocaleTimeString();

    function pickNUnique(arr, n) {
  const pool = [...arr];
  const out = [];
  while (out.length < n && pool.length) {
    const i = Math.floor(Math.random() * pool.length);
    out.push(pool.splice(i,1)[0]);
  }
  return out;
}

// Firestore: nested arrays 금지 → 문자열로 인코딩
function encodeTileOptions(opts) {
  return (opts || []).map(arr => Array.isArray(arr) ? arr.join('|') : '');
}
function decodeTileOptions(data) {
  return (data || []).map(val => {
    if (Array.isArray(val)) return val;         // 하위호환
    if (typeof val === 'string') return val ? val.split('|') : [];
    return [];
  });
}

    function pickId() { return Math.random().toString(36).slice(2, 10); }
    function randRoom() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let s = '';
      for (let i=0;i<6;i++) s += chars[Math.floor(Math.random()*chars.length)];
      return s;
    }

    function log(msg) {
      logEl.innerHTML = `<div><span class="text-slate-400">[${now()}]</span> ${msg}</div>` + logEl.innerHTML;
    }

    function shortName(name) {            // 탭용(최대 6자)
  const s = String(name || '');
  return s.length > 6 ? s.slice(0, 6) + '…' : s;
}
function abbrName(name) {             // 말(토큰)용 2자
  const s = String(name || '');
  return s.slice(0, 2);
}

    // ===== Game State (local mirror) =====
    let players = [];   // [{ id, name, color, pos, inv:Object, dishes:number, money:number, dishCounts:Object, rolls:number }]
    let turn = 0;       // index
    let viewPid = 0;

    let dice = null;               // 1..6
    let awaitingMove = false;
    let awaitingChoice = false;
    let animating = false;

    let tileOptions = []; // [[], [id,id,id], ...]
    let invCollapsed = false;
    let priceCollapsed = false;
    let showAllInventories = false;
    let orders = [];

    // ===== Firebase state =====
    let app = null, db = null;
    let online = false, isHost = false;
    let myId = localStorage.getItem('cc_myId') || pickId();
    localStorage.setItem('cc_myId', myId);

    let roomId = null;            // code
    let roomRef = null;
    let roomUnsub = null;

    // ===== Rendering =====
    function setButtons() {
  const isMyTurn = players.length && players[turn] && players[turn].id === myId;

  rollBtn.disabled = animating || awaitingMove || awaitingChoice || players.length === 0 || (online && !isMyTurn);
  moveForwardBtn.disabled = animating || !awaitingMove || awaitingChoice || (online && !isMyTurn);
  passBtn.disabled = animating || players.length === 0 || (online && !isMyTurn && !awaitingChoice && !awaitingMove);

  rollBtn.className = `px-4 py-2 rounded-xl text-white ${rollBtn.disabled ? 'bg-slate-300' : 'bg-indigo-500 hover:bg-indigo-600'}`;
  moveForwardBtn.className = `px-3 py-2 rounded-xl text-white ${moveForwardBtn.disabled ? 'bg-slate-300' : 'bg-emerald-500 hover:bg-emerald-600'}`;

  const p = players[turn] || { pos: 0 };
  const currentName = players.length ? (players[turn].name || `P${turn+1}`) : '-';
  turnLabel.textContent = currentName;
  posLabel.textContent = players.length ? `${p.pos} / ${PATH.length}` : `- / ${PATH.length}`;
  tileIndexEl.textContent = players.length ? p.pos : '-';
  ordersTarget.textContent = players.length ? (players[viewPid].name || `P${viewPid+1}`) : '-';

  const hintBase = online ? (players.length ? `(${isMyTurn ? '내 차례' : '상대 차례'})` : '') : '(로컬)';
  hintEl.textContent = !players.length
    ? '플레이어 수(1~6)를 입력해 시작하세요.'
    : awaitingMove
      ? `앞으로 ${dice}칸 이동하세요. ${hintBase}`
      : awaitingChoice
        ? `재료 1개 선택(1/2/3) 또는 건너뛰기(0). ${hintBase}`
        : `주사위를 굴리세요. ${hintBase}`;

  updateMoneyDishesUI();

  // 온라인 시작 버튼 상태
  if (startOnlineBtn) {
    const canStart = online && isHost && !!roomRef;
    startOnlineBtn.disabled = !canStart;
    startOnlineBtn.title = canStart ? '' : '호스트만 시작 가능 (방 생성/입장 필요)';
    startOnlineBtn.className = `px-2 py-1 rounded-lg ${canStart ? 'bg-emerald-500 text-white' : 'bg-slate-300 text-white'}`;
  }
}


    function updateMoneyDishesUI() {
      if (!players.length) { moneyLabel.textContent = '0'; dishesLabel.textContent = '0'; return; }
      moneyLabel.textContent = String((players[viewPid] || {}).money ?? 0);
      dishesLabel.textContent = String((players[viewPid] || {}).dishes ?? 0);
    }

    function renderInventoryListFor(playerIndex) {
      const wrapper = document.createElement('div');
      wrapper.className = 'rounded-xl border';
      const header = document.createElement('div');
      const pl = players[playerIndex];
      const dishTotal = Object.values(pl.dishCounts || {}).reduce((a,b)=>a+b,0);
      header.className = 'px-2 py-1 text-xs bg-slate-50 border-b flex items-center justify-between';
      header.innerHTML = `<span>플레이어 P${playerIndex+1}${pl.name?` · ${pl.name}`:''}</span><span class='text-[11px] text-slate-500'>보유 요리 ${dishTotal}개 · ₩${pl.money}</span>`;
      const ul = document.createElement('ul');
      ul.className = 'p-2 space-y-1';
      INGREDIENTS.forEach(meta => {
        const count = players.length ? ((pl.inv || {})[meta.id] || 0) : 0;
        const li = document.createElement('li');
        li.className = 'flex items-center justify-between px-2 py-1 rounded-lg border';
        li.innerHTML = `<span class="flex items-center gap-2"><span class="text-lg">${meta.icon}</span>${meta.label}</span><span class="font-mono">x ${count}</span>`;
        ul.appendChild(li);
      });
      wrapper.appendChild(header);
      wrapper.appendChild(ul);
      return wrapper;
    }

    function updateInventoryUI() {
  viewLabel.textContent = players[viewPid] ? (players[viewPid].name || `P${viewPid+1}`) : '-';
  updateMoneyDishesUI();

  invEl.innerHTML = '';
  if (invCollapsed) { invEl.classList.add('hidden'); return; }
  invEl.classList.remove('hidden');

  if (showAllInventories) {
    players.forEach((_, i) => invEl.appendChild(renderInventoryListFor(i)));
  } else if (players[viewPid]) {
    invEl.appendChild(renderInventoryListFor(viewPid));
  }
}


    function renderChoices() {
      choicesEl.innerHTML = '';
      if (!players.length) return;
      const pos = players[turn].pos;
      const opts = tileOptions[pos] || [];
      if (pos === 0) {
        const div = document.createElement('div');
        div.className = 'col-span-3 text-center text-slate-500 text-sm';
        div.textContent = '0번 칸: 재료 없음';
        choicesEl.appendChild(div);
        return;
      }
      const money = players[turn].money;
      opts.forEach((id, i) => {
        const meta = ingredientMeta(id);
        const cost = meta.price;
        const btn = document.createElement('button');
        btn.className = 'px-2 py-2 rounded-xl border text-sm hover:bg-slate-50 flex flex-col items-center gap-1 disabled:opacity-50 disabled:cursor-not-allowed';
        btn.innerHTML = `<span class="text-2xl leading-none">${meta.icon}</span><span>${meta.label}</span><span class="text-[11px] text-slate-600">₩${cost}</span><span class="text-[10px] text-slate-500">${i+1}</span>`;
        const disabledForTurn = online && players[turn].id !== myId;
        btn.disabled = (money < cost) || disabledForTurn || !awaitingChoice;
        btn.title = disabledForTurn ? '내 차례가 아닙니다' : (money < cost ? '돈이 부족합니다' : '');
        btn.addEventListener('click', () => chooseOption(i));
        choicesEl.appendChild(btn);
      });
      const skip = document.createElement('button');
      skip.className = 'col-span-3 px-2 py-2 rounded-xl border text-sm hover:bg-slate-50';
      const disabledForTurn = online && players[turn].id !== myId;
      skip.disabled = disabledForTurn || !awaitingChoice;
      skip.textContent = '재료 안 얻기 (0)';
      skip.addEventListener('click', () => chooseNone());
      choicesEl.appendChild(skip);
    }

    function renderPlayerTabs() {
  playerTabsEl.innerHTML = '';
  players.forEach((p, i) => {
    const btn = document.createElement('button');
    const activeTurn = (i === turn);
    const viewing = (i === viewPid);

    btn.className = `px-2 h-9 rounded-xl border grid place-items-center text-xs font-semibold whitespace-nowrap`
                    + (activeTurn ? ' ring-2 ring-indigo-500' : '')
                    + (viewing ? ' bg-slate-100' : '');
    btn.style.borderColor = p.color;
    btn.textContent = shortName(p.name || `P${i+1}`);
    btn.title = `플레이어 ${i+1}${p.name ? ` · ${p.name}` : ''}`;
    btn.addEventListener('click', () => { viewPid = i; updateInventoryUI(); renderPlayerTabs(); renderOrders(); });
    playerTabsEl.appendChild(btn);
  });
}


    // ===== Orders =====
    function rollOrders() {
      const ids = RECIPES.map(r=>r.id);
      orders = pickNUnique(ids, ORDER_COUNT);
    }

    function renderOrders() {
      ordersEl.innerHTML = '';
      if (!players.length) return;
      const viewer = players[viewPid];
      orders.forEach((rid) => {
        const r = RECIPES.find(x=>x.id===rid);
        const reqHtml = Object.entries(r.req).map(([id]) => ingredientMeta(id).icon).join(' ');
        const owned = (viewer.dishCounts || {})[r.id] || 0;
        const btn = document.createElement('button');
        btn.className = 'mt-2 w-full text-xs px-2 py-1 rounded-lg border disabled:opacity-50 disabled:cursor-not-allowed';
        btn.textContent = `주문 팔기 ×2 (₩${r.reward*2})`;
        btn.disabled = owned <= 0 || (online && viewer.id !== myId);
        btn.addEventListener('click', () => sellDish(r, 2));
        const card = document.createElement('div');
        card.className = 'border rounded-xl p-2';
        card.innerHTML = `<div class='flex items-center justify-between'><div class='flex items-center gap-2'><span class='text-xl'>${r.icon}</span><span class='font-semibold text-sm'>${r.name}</span></div><span class='text-xs text-slate-500'>보유 ${owned}개</span></div><div class='mt-1 text-sm'>${reqHtml}</div>`;
        card.appendChild(btn);
        ordersEl.appendChild(card);
      });
    }

    // ===== Dice & Move (local or online) =====
    function rollDice() {
      if (animating || awaitingMove || awaitingChoice || !players.length) return;
      if (online) return commitAction('ROLL', {});
      // local
      dice = 1 + Math.floor(Math.random() * 6);
      diceFace.textContent = String(dice);
      awaitingMove = true;
      players[turn].rolls += 1;
      log(`🎲 P${turn+1} 주사위: ${dice} (이번 라운드 ${players[turn].rolls}/5)`);
      if (players.every(p => p.rolls >= ROLLS_BEFORE_RESET)) {
        initOptions(); players.forEach(p => p.rolls = 0); renderChoices(); draw();
        log('🔁 모든 플레이어가 5회 굴림을 완료하여 모든 칸의 재료를 초기화했습니다.');
      }
      setButtons();
    }

    async function moveForward() {
      if (!awaitingMove || animating || !dice || awaitingChoice) return;
      if (online) return commitAction('MOVE', {});
      // local
      animating = true; setButtons();
      const steps = dice;
      for (let i = 0; i < steps; i++) {
        const p = players[turn];
        p.pos = mod(p.pos + 1, PATH.length);
        if (p.pos === 0) { p.money += PASS_ZERO_REWARD; log(`🎁 P${turn+1} 0칸 통과 보상 +₩${PASS_ZERO_REWARD}`); updateMoneyDishesUI(); }
        draw(); await delay(140);
      }
      log(`P${turn+1} ➡️ 앞으로 ${steps}칸 → 위치 ${players[turn].pos}`);
      dice = null; awaitingMove = false; diceFace.textContent = '–'; animating = false;
      if (players[turn].pos === 0) { endTurn(); } else { awaitingChoice = true; renderChoices(); setButtons(); }
    }

    function passTurn() {
      if (!players.length || animating) return;
      if (online) return commitAction('PASS', {});
      if (awaitingChoice) { chooseNone(); return; }
      if (awaitingMove) { log('⏭️ 이동 포기, 턴 종료'); dice = null; awaitingMove = false; diceFace.textContent = '–'; endTurn(); return; }
      log('⏭️ 턴 넘김'); endTurn();
    }

    function chooseOption(i) {
      if (!awaitingChoice) return;
      if (online) return commitAction('CHOOSE_OPTION', { index: i });
      const pos = players[turn].pos;
      const chosenId = (tileOptions[pos]||[])[i];
      const cost = priceOf(chosenId);
      const pl = players[turn];
      if (pl.money < cost) { log('💸 돈이 부족합니다.'); return; }
      pl.money -= cost;
      pl.inv[chosenId] = (pl.inv[chosenId] || 0) + 1;
      log(`👜 P${turn+1} ${ingredientMeta(chosenId).label} 획득 (₩${cost} 지불, 위치 ${pos})`);
      awaitingChoice = false; updateInventoryUI(); renderChoices(); endTurn();
    }

    function chooseNone() {
      if (!awaitingChoice) return;
      if (online) return commitAction('CHOOSE_NONE', {});
      log(`⏭️ P${turn+1} 재료 없이 지나감 (칸 ${players[turn].pos})`);
      awaitingChoice = false; endTurn();
    }

    function endTurn() {
      turn = (turn + 1) % players.length;
      dice = null; awaitingMove = false; awaitingChoice = false; diceFace.textContent = '–';
      renderPlayerTabs(); renderChoices(); renderOrders(); setButtons(); draw();
    }

    const delay = (ms) => new Promise(res => setTimeout(res, ms));

    // ===== Cook (Recipes) =====
    const canCook = (inv, recipe) => Object.entries(recipe.req).every(([id, need]) => (inv[id] || 0) >= need);

    function openCookModal() {
      if (!players.length) return;
      cookList.innerHTML = '';
      const pl = players[viewPid];
      const inv = pl.inv || {};
      RECIPES.forEach(r => {
        const can = canCook(inv, r);
        const owned = (pl.dishCounts || {})[r.id] || 0;
        const inOrders = orders.includes(r.id);
        const wrap = document.createElement('div');
        wrap.className = 'border rounded-xl p-3 flex flex-col gap-2';
        const reqHtml = Object.entries(r.req).map(([id, need]) => {
          const meta = ingredientMeta(id);
          const have = inv[id] || 0;
          return `<span class='inline-flex items-center gap-1 px-1 py-0.5 border rounded text-xs'>${meta.icon} ${meta.label} <span class='font-mono'>${have}/${need}</span></span>`;
        }).join(' ');
        wrap.innerHTML = `<div class='flex items-center justify-between'><div class='flex items-center gap-2'><span class='text-2xl'>${r.icon}</span><div><div class='font-semibold'>${r.name}</div><div class='text-xs text-slate-500'>보상 ₩${r.reward} · 보유 ${owned}개${inOrders?" · 주문 x2 대상":""}</div></div></div></div><div class='mt-1 space-x-1'>${reqHtml}</div>`;
        const row = document.createElement('div');
        row.className = 'flex items-center gap-2';
        const cookB = document.createElement('button');
        cookB.className = 'px-2 py-1 rounded-lg text-xs bg-rose-500 text-white disabled:opacity-50 disabled:cursor-not-allowed';
        cookB.textContent = '요리';
        const cookDisabled = online ? (players[viewPid].id !== myId || !can) : !can;
        cookB.disabled = cookDisabled;
        cookB.title = cookDisabled && online ? '본인만 조리할 수 있습니다' : '';
        cookB.addEventListener('click', () => { cookRecipe(r); openCookModal(); });
        const sellB = document.createElement('button');
        sellB.className = 'px-2 py-1 rounded-lg text-xs border disabled:opacity-50 disabled:cursor-not-allowed';
        sellB.textContent = inOrders ? `팔기 ×2 (₩${r.reward*2})` : `팔기 (₩${r.reward})`;
        const sellDisabled = online ? (players[viewPid].id !== myId || owned <= 0) : (owned <= 0);
        sellB.disabled = sellDisabled;
        sellB.addEventListener('click', () => { sellDish(r, inOrders?2:1); openCookModal(); });
        row.appendChild(cookB); row.appendChild(sellB);
        wrap.appendChild(row);
        cookList.appendChild(wrap);
      });
      cookModal.classList.add('show');
    }

    function closeCookModal() { cookModal.classList.remove('show'); }

    function cookRecipe(recipe) {
      if (online) return commitAction('COOK', { targetId: myId, recipeId: recipe.id });
      const pl = players[viewPid]; if (pl.id !== myId) return;
      const inv = pl.inv;
      if (!canCook(inv, recipe)) return;
      Object.entries(recipe.req).forEach(([id, need]) => inv[id] = (inv[id] || 0) - need);
      pl.money += recipe.reward; pl.dishes += 1; pl.dishCounts[recipe.id] = (pl.dishCounts[recipe.id] || 0) + 1;
      log(`👨‍🍳 ${recipe.name} 완성! (${recipe.icon}) — P${viewPid+1} +₩${recipe.reward}`);
      updateInventoryUI(); renderOrders();
    }

    function sellDish(recipe, multiplier = 1) {
      if (online) return commitAction('SELL', { targetId: myId, recipeId: recipe.id, mult: multiplier });
      const pl = players[viewPid]; if (pl.id !== myId) return;
      const count = pl.dishCounts[recipe.id] || 0; if (count <= 0) return;
      pl.dishCounts[recipe.id] = count - 1; const amount = recipe.reward * multiplier; pl.money += amount;
      if (multiplier >= 2) pl.dishes += 1; // 주문 판매 시 추가 +1
      log(`💰 ${recipe.name} 판매 — P${viewPid+1} +₩${amount}${multiplier>=2?' (주문 x2)':''}`);
      updateInventoryUI(); renderOrders();
    }

    // ===== Price List =====
    function renderPriceList() {
      priceList.innerHTML = '';
      if (priceCollapsed) { priceList.classList.add('hidden'); return; }
      priceList.classList.remove('hidden');
      INGREDIENTS.forEach(meta => {
        const row = document.createElement('div');
        row.className = 'flex items-center justify-between border rounded-lg px-2 py-1';
        row.innerHTML = `<span class='flex items-center gap-2'><span class='text-lg'>${meta.icon}</span>${meta.label}</span><span class='font-mono'>₩${meta.price}</span>`;
        priceList.appendChild(row);
      });
    }

    // ===== Render (Canvas) =====
    function drawBoard() {
      ctx.fillStyle = '#f8fafc';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (let gy = 0; gy < ROWS; gy++) {
        for (let gx = 0; gx < COLS; gx++) {
          const r = tileRect(gx, gy);
          ctx.fillStyle = '#e2e8f0';
          ctx.fillRect(r.x, r.y, r.w, r.h);
          ctx.strokeStyle = '#cbd5e1';
          ctx.strokeRect(r.x, r.y, r.w, r.h);
        }
      }
      ctx.fillStyle = '#64748b';
      ctx.font = '14px ui-sans-serif, Apple Color Emoji, Segoe UI Emoji';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      PATH.forEach((p, i) => {
        const c = centerOf(p.gx, p.gy);
        ctx.fillStyle = '#64748b'; ctx.fillText(String(i), c.x, c.y);
        if (i > 0) {
          const opts = tileOptions[i]; if (opts) {
            const metas = opts.map(id => ingredientMeta(id));
            ctx.fillText(metas[0].icon, c.x - 18, c.y - 24);
            ctx.fillText(metas[1].icon, c.x,       c.y - 24);
            ctx.fillText(metas[2].icon, c.x + 18, c.y - 24);
          }
        }
      });
    }

    function drawTokens() {
  players.forEach((pl, i) => {
    const p = PATH[pl.pos];
    const c = centerOf(p.gx, p.gy);
    const offsetAngle = (i * (Math.PI * 2)) / Math.max(4, players.length);
    const rOff = 10;
    const ox = Math.cos(offsetAngle) * rOff;
    const oy = Math.sin(offsetAngle) * rOff;

    ctx.beginPath();
    ctx.arc(c.x + ox, c.y + oy, TILE * 0.26, 0, Math.PI * 2);
    ctx.fillStyle = pl.color;
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#1f2937';
    ctx.stroke();

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px ui-sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(abbrName(pl.name || `P${i+1}`), c.x + ox, c.y + oy);  // ← 변경된 라벨

    if (i === turn) {
      ctx.beginPath();
      ctx.arc(c.x + ox, c.y + oy, TILE * 0.32, 0, Math.PI * 2);
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
}


    function draw() { drawBoard(); drawTokens(); }

    // ===== Events =====
    rollBtn.addEventListener('click', rollDice);
    moveForwardBtn.addEventListener('click', moveForward);
    passBtn.addEventListener('click', passTurn);
    resetBtn.addEventListener('click', startGameLocal);

    cookBtn.addEventListener('click', openCookModal);
    cookClose.addEventListener('click', closeCookModal);
    cookModal.addEventListener('click', (e) => { if (e.target === cookModal) closeCookModal(); });

    invToggle.addEventListener('click', () => { invCollapsed = !invCollapsed; invToggle.textContent = invCollapsed ? '펼치기' : '접기'; updateInventoryUI(); });
    allInvToggle.addEventListener('click', () => { showAllInventories = !showAllInventories; allInvToggle.textContent = showAllInventories ? '한 명 보기' : '모두 보기'; updateInventoryUI(); });
    priceToggle.addEventListener('click', () => { priceCollapsed = !priceCollapsed; priceToggle.textContent = priceCollapsed ? '펼치기' : '접기'; renderPriceList(); });

    window.addEventListener('keydown', (e) => {
      if (!players.length) return; if (animating) return;
      if (!awaitingMove && !awaitingChoice && (e.key === 'r' || e.key === 'R')) { e.preventDefault(); rollDice(); }
      if (awaitingMove && (e.key === 'Enter' || e.key === 'ArrowUp' || e.key === 'f' || e.key === 'F')) { e.preventDefault(); moveForward(); }
      if (!awaitingMove && !awaitingChoice && (e.key === 'n' || e.key === 'N')) { e.preventDefault(); passTurn(); }
      if (awaitingChoice) {
        if (['1','2','3'].includes(e.key)) {
          const i = Number(e.key) - 1; const pos = players[turn].pos; const opts = tileOptions[pos] || []; const id = opts[i];
          if (id && (!online || players[turn].id===myId) && players[turn].money >= priceOf(id)) { e.preventDefault(); chooseOption(i); }
        } else if (e.key === '0' || e.key === 'Escape' || e.key === ' ') { e.preventDefault(); chooseNone(); }
      }
    });

    // ===== Local-only init =====
    function initOptions() {
      const ids = INGREDIENTS.map(x=>x.id);
      tileOptions = Array.from({ length: PATH.length }, (_, i) => i === 0 ? [] : pickNUnique(ids, 3));
    }

    function startGameLocal() {
      const nStr = prompt('플레이어 수를 입력하세요 (1~6):', '2');
      let n = parseInt(nStr, 10); if (!Number.isFinite(n)) n = 2; n = Math.max(1, Math.min(6, n));
      players = Array.from({ length: n }, (_, i) => ({ id: pickId(), name: `P${i+1}`, pos: 0, inv: {}, color: PLAYER_COLORS[i % PLAYER_COLORS.length], dishes: 0, money: START_MONEY, dishCounts: {}, rolls: 0 }));
      turn = 0; viewPid = 0; dice = null; awaitingMove = false; awaitingChoice = false; animating = false; diceFace.textContent = '–';
      invCollapsed = false; invToggle.textContent = '접기'; priceCollapsed = false; priceToggle.textContent = '접기'; showAllInventories = false; allInvToggle.textContent = '모두 보기';
      initOptions(); rollOrders(); renderPlayerTabs(); updateInventoryUI(); renderChoices(); renderPriceList(); renderOrders(); setButtons(); draw();
      log(`로컬 게임 시작 — 플레이어 ${n}명 / 시작 자금 ₩${START_MONEY}`);
    }

    // ===== Firebase bootstrap =====
    try {
      if (FIREBASE_CONFIG && FIREBASE_CONFIG.projectId) {
        app = firebase.initializeApp(FIREBASE_CONFIG);
        db = firebase.firestore();
        mpStatus.textContent = 'Firebase 연결됨';
      } else {
        mpStatus.textContent = '로컬 모드 (Firebase 설정 필요)';
      }
    } catch (e) {
      console.warn(e); mpStatus.textContent = '로컬 모드 (Firebase 오류)';
    }

    // ===== Multiplayer helpers =====
    function stateSkeleton() {
      return {
        status: 'lobby', // 'lobby' | 'playing'
        hostId: null,
        version: 0,
        createdAt: firebase.firestore.FieldValue.serverTimestamp?.() || null,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp?.() || null,
        players: [], // array of player objects
        turn: 0,
        dice: null,
        awaitingMove: false,
        awaitingChoice: false,
        tileOptions: [],
        orders: [],
      };
    }

    function toDocPlayer(p) {
      return { id: p.id, name: p.name, color: p.color, pos: p.pos, money: p.money, dishes: p.dishes, inv: p.inv, dishCounts: p.dishCounts, rolls: p.rolls };
    }

    function fromDocState(s) {
  players = (s.players || []).map(p => ({...p}));
  turn = s.turn || 0; dice = s.dice || null; awaitingMove = !!s.awaitingMove; awaitingChoice = !!s.awaitingChoice;

  tileOptions = decodeTileOptions(s.tileOptions); // ← 변경
  orders = s.orders || [];

  viewPid = Math.min(viewPid, Math.max(0, players.length-1));
  diceFace.textContent = dice ? String(dice) : '–';
  renderPlayerTabs(); updateInventoryUI(); renderChoices(); renderOrders(); setButtons(); draw();
}

    async function createRoom() {
  if (!db) { alert('Firebase 설정이 필요합니다.'); return; }
  const code = randRoom();
  const ref = db.collection('rooms').doc(code);
  const name = (nameInput.value.trim() || `호스트-${myId.slice(0,4)}`).slice(0,16);
  const hostPlayer = {
    id: myId, name,
    color: PLAYER_COLORS[0],
    pos: 0, money: START_MONEY, dishes: 0,
    inv: {}, dishCounts: {}, rolls: 0
  };
  await ref.set({
    ...stateSkeleton(),
    hostId: myId,         // ← 호스트 지정
    players: [hostPlayer] // ← 호스트를 players에 등록
  });
  isHost = true; online = true; roomId = code; roomRef = ref; subscribeRoom();
  mpStatus.textContent = `방 생성: ${code} (호스트)`; roomInput.value = code;
  log(`🛠️ 방 생성: ${code}`);
}

async function joinRoom() {
  if (!db) { alert('Firebase 설정이 필요합니다.'); return; }
  const code = roomInput.value.trim().toUpperCase(); if (!code) return alert('방 코드를 입력하세요');
  const name = (nameInput.value.trim() || `손님-${myId.slice(0,4)}`).slice(0,16);
  const ref = db.collection('rooms').doc(code); const snap = await ref.get();
  if (!snap.exists) return alert('방이 존재하지 않습니다');

  const s0 = snap.data();
  isHost = (s0.hostId === myId); // ← 추가: 내 ID가 hostId면 호스트

  await db.runTransaction(async (t) => {
    const s = (await t.get(ref)).data();
    let ps = s.players || [];
    if (!ps.find(p => p.id === myId)) {
      if (ps.length >= 6) throw new Error('정원 초과');
      ps = [...ps, { id: myId, name, color: PLAYER_COLORS[ps.length % PLAYER_COLORS.length], pos: 0, money: START_MONEY, dishes: 0, inv: {}, dishCounts: {}, rolls: 0 }];
    }
    t.update(ref, { players: ps, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version: (s.version||0)+1 });
  });
  online = true; roomId = code; roomRef = ref; subscribeRoom();
  mpStatus.textContent = `입장: ${code} (${isHost ? '호스트' : '게스트'})`;
  log(`🚪 방 입장: ${code}`);
}


    async function leaveRoom() {
      if (!online || !roomRef) return;
      roomUnsub && roomUnsub(); roomUnsub = null;
      // 방에서 내 플레이어 제거(게임 중엔 남겨둘 수도 있음)
      try {
        await db.runTransaction(async (t) => {
          const s = (await t.get(roomRef)).data();
          const ps = (s.players || []).filter(p => p.id !== myId);
          t.update(roomRef, { players: ps, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version: (s.version||0)+1 });
        });
      } catch {}
      online = false; isHost = false; roomId = null; roomRef = null; mpStatus.textContent = '로컬 모드';
      log('👋 방 나가기');
    }

    function subscribeRoom() {
  roomUnsub && roomUnsub();
  roomUnsub = roomRef.onSnapshot((snap) => {
    if (!snap.exists) return;
    const s = snap.data();
    isHost = (s.hostId === myId); // ← 추가
    fromDocState(s);
    mpStatus.textContent = `${roomId} · ${s.status === 'lobby' ? '대기실' : '게임중'} · ${isHost ? '호스트' : '게스트'}`;
  });
}

    async function startOnline() {
  if (!online || !roomRef) { log('⚠️ 방에 연결되지 않았습니다'); return; }
  if (!isHost) { log('⚠️ 호스트만 시작할 수 있습니다'); return; }
  try {
    log('⏳ 온라인 시작 시도');
    await db.runTransaction(async (t) => {
      const doc = await t.get(roomRef); const s = doc.data();
      if ((s.players||[]).length < 1) throw new Error('플레이어 없음');
      const ids = INGREDIENTS.map(x=>x.id);
      const newOpts = Array.from({ length: PATH.length }, (_, i) => i === 0 ? [] : pickNUnique(ids, 3));
      const ord = pickNUnique(RECIPES.map(r=>r.id), ORDER_COUNT);
      const ps = (s.players||[]).map((p,i)=>({ ...p, pos:0, money:START_MONEY, dishes:0, inv:{}, dishCounts:{}, rolls:0, color: PLAYER_COLORS[i % PLAYER_COLORS.length] }));
      t.update(roomRef, {
        status:'playing',
        tileOptions: encodeTileOptions(newOpts), // ← 변경
        orders: ord,
        players: ps,
        turn: 0, dice: null,
        awaitingMove:false, awaitingChoice:false,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        version:(s.version||0)+1
      });
    });
    log('🚀 온라인 게임 시작');
  } catch (e) {
    console.warn(e); log(`❌ 시작 실패: ${e.message || e}`);
  }
}

    async function commitAction(type, payload) {
      if (!online || !roomRef) return;
      try {
        await db.runTransaction(async (t) => {
          const doc = await t.get(roomRef); if (!doc.exists) throw new Error('방이 없습니다');
          const s = doc.data();
          if (s.status !== 'playing') throw new Error('아직 시작되지 않음');
          const ps = [...(s.players||[])];
          const meIdx = ps.findIndex(p => p.id === myId);
          const turnIdx = s.turn || 0; const turnPlayer = ps[turnIdx];
          const isMyTurn = turnPlayer && turnPlayer.id === myId;
          const ids = INGREDIENTS.map(x=>x.id);

          const endTurn = (state) => { state.turn = (state.turn + 1) % state.players.length; state.dice = null; state.awaitingMove = false; state.awaitingChoice = false; };

          switch (type) {
            case 'ROLL': {
  if (!isMyTurn) throw new Error('내 차례가 아님');
  if (s.awaitingMove || s.awaitingChoice || s.dice) throw new Error('이미 굴림');
  const d = 1 + Math.floor(Math.random() * 6);
  ps[turnIdx].rolls = (ps[turnIdx].rolls || 0) + 1;

  let newOpts = s.tileOptions; // 현재 저장 형식(문자열 배열)
  if (ps.every(p => (p.rolls||0) >= ROLLS_BEFORE_RESET)) {
    const fresh = Array.from({ length: PATH.length }, (_, i) => i === 0 ? [] : pickNUnique(ids, 3));
    newOpts = encodeTileOptions(fresh);        // ← 변경
    ps.forEach(p => p.rolls = 0);
  }

  t.update(roomRef, {
    players: ps,
    dice: d,
    awaitingMove: true,
    tileOptions: newOpts,                      // ← 문자열 배열 보장
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    version:(s.version||0)+1
  });
  break;
}

            case 'MOVE': {
              if (!isMyTurn) throw new Error('내 차례가 아님');
              if (!s.awaitingMove || !s.dice) throw new Error('이동 불가');
              let pos = ps[turnIdx].pos || 0; const steps = s.dice; let money = ps[turnIdx].money || 0;
              for (let i=0;i<steps;i++){ pos = (pos + 1) % PATH.length; if (pos===0) money += PASS_ZERO_REWARD; }
              ps[turnIdx].pos = pos; ps[turnIdx].money = money;
              const next = { ...s, players: ps, dice: null, awaitingMove: false, awaitingChoice: pos!==0, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version:(s.version||0)+1 };
              if (pos===0) { endTurn(next); }
              t.update(roomRef, next);
              break;
            }
            case 'CHOOSE_OPTION': {
  if (!isMyTurn) throw new Error('내 차례가 아님');
  if (!s.awaitingChoice) throw new Error('선택 단계가 아님');
  const pos = ps[turnIdx].pos || 0;
  const opts = decodeTileOptions(s.tileOptions)[pos] || []; // ← 변경
  const idx = payload.index|0; const chosenId = opts[idx];
  const cost = priceOf(chosenId);
  if ((ps[turnIdx].money||0) < cost) throw new Error('돈 부족');
  ps[turnIdx].money -= cost; ps[turnIdx].inv = ps[turnIdx].inv || {}; ps[turnIdx].inv[chosenId] = (ps[turnIdx].inv[chosenId]||0) + 1;
  const next = { ...s, players: ps, awaitingChoice: false, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version:(s.version||0)+1 };
  endTurn(next);
  t.update(roomRef, next);
  break;
}

            case 'CHOOSE_NONE': {
              if (!isMyTurn) throw new Error('내 차례가 아님');
              if (!s.awaitingChoice) throw new Error('선택 단계가 아님');
              const next = { ...s, awaitingChoice: false, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version:(s.version||0)+1 };
              endTurn(next); t.update(roomRef, next); break;
            }
            case 'PASS': {
              if (!isMyTurn) throw new Error('내 차례가 아님');
              const next = { ...s, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version:(s.version||0)+1 };
              if (s.awaitingChoice) { next.awaitingChoice = false; }
              else if (s.awaitingMove) { next.awaitingMove = false; next.dice = null; }
              endTurn(next); t.update(roomRef, next); break;
            }
            case 'COOK': {
              const pIdx = ps.findIndex(p => p.id === payload.targetId); if (pIdx < 0) throw new Error('플레이어 없음');
              if (payload.targetId !== myId) throw new Error('본인만 조리 가능');
              const recipe = RECIPES.find(r=>r.id===payload.recipeId); if (!recipe) throw new Error('레시피 없음');
              const inv = ps[pIdx].inv || {}; const ok = Object.entries(recipe.req).every(([id,need]) => (inv[id]||0) >= need);
              if (!ok) throw new Error('재료 부족');
              Object.entries(recipe.req).forEach(([id,need]) => inv[id] = (inv[id]||0) - need);
              ps[pIdx].money = (ps[pIdx].money||0) + recipe.reward; ps[pIdx].dishes = (ps[pIdx].dishes||0) + 1; ps[pIdx].dishCounts = ps[pIdx].dishCounts || {}; ps[pIdx].dishCounts[recipe.id] = (ps[pIdx].dishCounts[recipe.id]||0) + 1;
              t.update(roomRef, { players: ps, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version:(s.version||0)+1 });
              break;
            }
            case 'SELL': {
              const pIdx = ps.findIndex(p => p.id === payload.targetId); if (pIdx < 0) throw new Error('플레이어 없음');
              if (payload.targetId !== myId) throw new Error('본인만 판매 가능');
              const recipe = RECIPES.find(r=>r.id===payload.recipeId); if (!recipe) throw new Error('레시피 없음');
              ps[pIdx].dishCounts = ps[pIdx].dishCounts || {}; const count = ps[pIdx].dishCounts[recipe.id] || 0; if (count <= 0) throw new Error('보유 없음');
              ps[pIdx].dishCounts[recipe.id] = count - 1; const amount = recipe.reward * (payload.mult||1); ps[pIdx].money = (ps[pIdx].money||0) + amount;
              if ((payload.mult||1) >= 2) ps[pIdx].dishes = (ps[pIdx].dishes||0) + 1;
              t.update(roomRef, { players: ps, updatedAt: firebase.firestore.FieldValue.serverTimestamp(), version:(s.version||0)+1 });
              break;
            }
            default: throw new Error('알 수 없는 액션');
          }
        });
      } catch (e) {
        console.warn(e); log(`⚠️ ${e.message || e}`);
      }
    }

    // ===== Multiplayer UI binds =====
    createRoomBtn.addEventListener('click', createRoom);
    joinRoomBtn.addEventListener('click', joinRoom);
    leaveRoomBtn.addEventListener('click', leaveRoom);
    startOnlineBtn.addEventListener('click', startOnline);

    // ===== Boot =====
    (function init() {
      nameInput.value = localStorage.getItem('cc_name') || '';
      nameInput.addEventListener('change', () => localStorage.setItem('cc_name', nameInput.value.trim()));
      setButtons(); draw(); startGameLocal();
    })();
  </script>
</body>
</html>
